## 1. React의 렌더링이란?

React에서 "렌더링"이란 상태(state)나 props 등의 데이터가 변경되었을 때 컴포넌트가 이를 반영하여 UI를 다시 그리는 과정이다. 하지만 React는 단순히 다시 그리는 게 아니라 "**효율적으로** 다시 그리는 것"을 목표로 삼는다.

React는 다음의 상황에서 렌더링을 시작한다:

- `setState`, `useState`, `useReducer`로 상태가 변경됨
- 부모 컴포넌트로부터 받은 props가 변경됨
- Context 값이 변경됨
- 강제로 `forceUpdate()` 호출됨 (Class 기반 컴포넌트)

## 2. 렌더링의 큰 흐름

렌더링은 단순한 하나의 과정이 아니다. React는 이 과정을 두 단계로 나누어 처리한다:

### Render Phase

- 컴포넌트 함수를 다시 실행하여 새로운 React Element 트리를 생성한다.
- 아직 실제 DOM에는 아무 영향도 없음
- 이 과정에서 `useMemo`, `useCallback`, `React.memo` 등이 작동한다

### Commit Phase

- 변화가 감지되면 실제 DOM을 업데이트
- `ref` 연결
- 라이프사이클 메서드 또는 훅 실행 (`useEffect`, `useLayoutEffect`, etc.)

> React는 이 두 단계를 명확하게 구분함으로써, 상태 변경 → DOM 반영까지의 흐름을 구조적으로 최적화한다.

## 3. 렌더링 예시로 이해하기

```tsx
const [count, setCount] = useState(0);
return <p>{count}</p>
```

- `setCount(1)` 호출 시
    - Render Phase: `count`가 1인 상태로 컴포넌트 함수가 다시 실행됨
    - 새로운 VDOM: `<p>1</p>` 생성
    - 이전 VDOM과 비교: 텍스트만 다름
    - Commit Phase: `p` 태그의 텍스트만 DOM에서 변경됨

## 4. 렌더링 시 주의할 점

- 상태가 바뀐다고 항상 화면이 변경되는 것은 아니다 (React.memo, useMemo 등을 통해 방지 가능)
- 부모가 렌더링된다고 자식이 반드시 리렌더링되진 않는다 (props가 같다면 재사용됨)
- 렌더링 타이밍을 정확히 이해하면 불필요한 재연산을 줄이고 성능을 향상시킬 수 있다

---

# Virtual DOM & Diffing (ver.2)

## 1. DOM 조작의 문제점

HTML DOM은 인터페이스는 직관적이지만, 조작 시 성능 저하가 발생하기 쉬운 구조다.

- DOM을 직접 수정하면 브라우저는 Reflow, Repaint 등의 비용이 큰 작업을 수행
- 특히 노드가 많거나 복잡한 레이아웃일 경우 렌더링 속도가 급격히 저하된다

## 2. Virtual DOM의 등장 배경

React는 이를 해결하기 위해 "Virtual DOM"이라는 중간 레이어를 도입했다. 이는 다음과 같은 구조로 작동한다:

- 컴포넌트가 JSX를 반환하면 React는 이를 React Element라는 객체로 변환
- 이 객체들을 트리 구조로 구성한 것이 Virtual DOM
- 상태가 변경되면 새로운 VDOM을 만들고, 이전 VDOM과 비교하여 변경된 부분만 실제 DOM에 반영

## 3. 예시로 이해하기

```tsx
const App = () => <div><h1>Hello</h1></div>;
```

내부적으로 React는 이를 다음과 같이 해석한다:

```js
{
  type: 'div',
  props: {
    children: {
      type: 'h1',
      props: {
        children: 'Hello'
      }
    }
  }
}
```

## 4. Diffing 알고리즘의 작동 방식

### 기본 원리
- 두 개의 VDOM을 비교
- 다른 부분을 찾아서 실제 DOM에 적용

### 최적화 규칙
- 태그 이름이 다르면 해당 노드 완전 교체
- key가 다르면 해당 리스트 항목 교체
- 같은 태그 + 같은 key면 props만 비교하여 최소한의 변경 적용

```tsx
{items.map(item => <li key={item.id}>{item.name}</li>)}
```

위처럼 `key`를 명시함으로써 React는 리스트 재정렬 시 불필요한 리렌더링을 방지한다.

## 5. 실제 반영 흐름

1. 상태 변경으로 컴포넌트 재실행 → 새로운 React Element 트리 생성
2. 기존 트리와 비교
3. 변경된 부분만 Update Queue에 저장
4. Commit Phase에서 DOM을 한 번에 갱신

## 6. VDOM의 효과

- 직접 DOM을 건드리는 횟수를 줄임 → 성능 개선
- 변경점을 모아서 일괄 처리 가능 → Batching 최적화
- React Native, Server Side 등 다양한 플랫폼에서도 렌더링 추상화 가능

> VDOM은 단순한 퍼포먼스 향상을 넘어서, React의 렌더링 모델을 가능하게 만든 핵심 기반이다.

